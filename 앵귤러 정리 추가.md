# AngularJS

### 디렉티브
HTML 태그나 어트리뷰트의 기능을 새롭게 만드는 개념. 애플리케이션의 요구 사항에 맞게 HTML 태그를 확장할 수 있다.

### ng-app
<div>에 ng-app 어트리뷰트를 추가하면 그 <div>만 AngularJS의 영향을 받는다.

### 바인딩
뷰와 모델이 서로를 갱신하는것. AngularJS는 모델이 갱신될 때마다 전체 애플리케이션에 영향을 미치는 $digest 함수를 실행하면서 데이터 바인딩을 점검하고 DOM 객체의 값을 갱신한다.

### socpe
모델의 값은 $scope라는 스코프 안에 선언되며 AngularJS에서는 이 스코프를 여러 계층으로 구성한다.

# Angular

### NgModule
모듈은 클래스에 @NgModule 어노테이션을 붙여서 지정하고 이 어노테이션 안에서 모듈 내용을 설정한다.

### SystemJS 모듈로더
JS는 script 태그 안에서 로드하고 실행하지만 Angular도 이 방법을 사용할 수 있지만 SystemJS 라이브러리를 사용해서 불러오는것을 권장한다.
why? 스크립트 태그를 삭제하지 않으면 이를 불러오려고 하고 불필요한 부하 발생 , 스크립트 태그의 실행순서를 보장하지 않기 때문에 문제가 될 수 있다.

environment.ts 파일 -> 빌드를 위한 개발환경 설정 정보들

## 빌드명령어
Angular-CLI로 만들어진 프로젝트의 코드는 타입스크립트 기반이기 때문에 빌드를 통해 브라우저에서 동작 가능한 자바스크립트로 변환해야 한다.

ng build

프로덕션용 빌드 명령어
ng build --prod

# 타입스크립트

## 1.let을 이용한 변수선언
ES 5 이하에서 호이스팅 문제가 발생하므로 이를 해결하기 위해 ES6의 좋은 특징인 let 선언자를 이용

타입스크립트는 변수명 뒤에 타입을 명시해야 한다. 타입스크립트를 타입 언어라고 하는 이유는 이와 같은 이유이다.
let 변수명 : 타입;
let emotion2:string="happy";

## 배열타입
#### 배열정의 형태1
let fruits: string[] = ["a","b"];


let fruits2: string[] = [];
fruits2.push("a");

#### 배열정의 형태2
let num:Array<number> = [1,2,3];


## 유니언 타입 56p
유니언 타입은 2개 이상으로 입력된 타입에 대해 하나의 타입으로 정의하는것. 메소드의 파라미터로 사용가능.
var unionX: string | number = 1;
console.log(typeof unionX, unionX); // number 1 출력


## 문자열 표현 58p
+와 \n을 써서 줄바꿈이 가능하지만 다음과 같이 가능하다.
let w: string ="world";
let one: number = 1;
function hi(){
    return "hi";
}

let hello_message: string =`
hello ${w}
1 + ${one} = ${1+1}
${hi()}
`
console.log(hello_message);


## 디스트럭처링 지원 60p
ES6에 포함된 특징으로 배열이나 객체에서 데이터를 선택적으로 추출할 수 있는 자바스크립트 할당식이다.
var params2 = ['happy 동물원', 100];
let[m_name2, m_num2] = params2;


## 컴포넌트
앵귤러에서 화면하는 구성하는 중요한 구성요소이다.

### 웹 컴포넌트
HTML , CSS, 자바스크립트를 하나의 단위로 묶어주는 기술이다. 웹 컴포넌트 기술은 하나의 기능이 아니라 여러가지 기술들이 합쳐져 하나의 웹 컴포넌트를 구성
 웹 컴포넌트는 앵귤러2 컴포넌트의 기반기술이다 앵귤러 2 컴포넌트는 웹 컴포넌트의 기술요소를 기반으로 하므로 웹 컴포넌트를 이해하면 앵귤러 컴포넌트를 이해하는 데 도움된다.
1. HTML 템플릿
2. 템플릿 호출
3. 쉐도우 DOM
4. 커스텀 엘리먼트



### 중첩컴포넌트 85p
부모 컴포넌트가 여러 자식컴포넌트를 포함하는 경우

### 컴포넌트 트리 86p
평면적으로 나열된 컴포넌트가 어떤 포함 관계를 가지는지 알수있게 해줌

### 컴포넌트 기반 개발 87p
컴포넌트를 개발의 중심에 두고 개발하는것.

## 컴포넌트 89p
컴포넌트 내부는 크게 import 영역, @Component 장식자(selector, template, styles로 구성됨), 컴포넌트 클래스 영역으로 나뉜다.

## 부모가 자식한테 값 전달
부모가 속성바인드를 통해 값을 전달하면 자식이 값을 받는 방법은 2가지가 있다.

### @input 장식자 99p
외부에서 전달된 값을 받기 위해 사용하는 장식자


### inputs 102p
부모가 name1, name2 속성으로 어떠한 값을 전달하면 자식은 @Component장식자 안에 inputs:['name1','name2']로 값을 받을 수 있다. 자식의 클래스에서도 name1, name2를 지정해줘야함

## 자식이 부모한테 값 전달 103p
@Output 장식자로 선언한 변수를 EventEmitter로 초기화한다. 그리고 부모에게 보낼 시점이 되면 emit()메소드를 사용해 부모로 이벤트를 전달한다.

### @ViewChild 장식자 107p
화면 DOM에 접근해 첫 번째로 위치한 지시자의 내부 상태(지시자의 속성값)나 정보(컴포넌트 지시자의 경우 내부 메서드)를 가져온다

### @ViewChildren 장식자 109p
@ViewChild는 하나의 엘리먼트 상태를 갖고왔지만 @ViewChildren 장식자는 여러 지시자의 상태를 한번에 취할 수 있다.

### @ContentChild 장식자 112p
콘텐츠 DOM을 탐색해 지시자 엘리먼트의 상태를 QueryList에 담는 역할을 한다.

### @ContentChildren 장식자 114p
컴포넌트 내부에 위치한 엘리먼트나 지시자에 정보를 담고 있는 쿼리리스트를 얻는다.

### 쉐도우 DOM의 선택자 118p
그냥 styles:['span{font-style}'] 이런식으로 하면 해당 컴포넌트의 span만 적용된다. 이를 범위를 넓히거나 좁힐때 사용하는것이 쉐도우 DOM의 선택자이다.
1.:host 선택자
2.:host-context 선택자
3.:deep 선택자

# 서비스
앵귤러JS(앵귤러2아님)에서는 기능을 컨트롤러에서 분리하기 위해 서비스 메소드를 써야할지 팩토리 메소드를 써야할지 혼란이 있었으나 2에서는 팩토리와 서비스를 서비스로 단일화 하였고 메소드에서 클래스로 변경하였다.
서비스는 공통관심사를 묶어놓았다.
provider제공자 그리고 @Injectable() 장식자 이용

### 서비스 특징
1. 서비스는 의존성 주입이 가능하다. 132p
2. 객체지향적으로 이용가능
3. 목 객체 서비스로 이용가능(서버,외부의 의존성없이 테스트 코드 작성할 때 유용) 135p
4. 프로미스 서비스 (콜백헬과같은 비정상적인 호출형태를 개선하기 위해 나옴) 138p
5. 서비스를 이용한 데이터 교환 가능(부모는 provider 설정을 해줘야하지만 자식은 안한다.)

# 모듈
앵귤러 애플리케이션을 구성하는 뼈대와 같은 역할. @NgModule 장식자를 이용한다
import {Component} from '@angular/core';
와 같이 이용하는데 Component는 사용할 모듈이고, @angular/core는 패키지이다.


### 라이브러리 모듈 147p
앵귤러가 제공하는 모듈. ex) 지시자, 파이프, 장식자, 클래스, 인터페이스, 함수, Enum, 타입 별칭(type alias), 상수

### 사용자 정의 모듈 147p
컴포넌트나 지시자와 같이 장식자를 이용한 모듈과 서비스와 함수 값과 같이 장식자가 없는 모듈로 구분됨.
외부로 공개할 모듈은 export를 이용해 선언(ES6부터 지원)

### 애플리케이션 루트 모듈 149p
앵귤러는 애플리케이션 루트 모듈이라는 최상위 모듈을 통행 애플리케이션 모듈을 구성한다. 하지만 이 안에 모든 모듈을 구성할 수 없기 떄문에 의미론적으로 - 특징모듈 (개별 컴포넌트 단위가 아닌 단위 애플리케이션을 구성하는 모듈)
- 공유모듈 (다른 모듈에 포함되어 동작하는 모듈 (반복적으로 선언되는 모듈))
- 핵심모듈 (애플리케이션에서 항상 동작할 필요가 있거나 애플리케이션의 전체적인 동작에 핵심적인 역할을 하는 모듈(ex) 타이틀 컴포넌트)
로 나눔.

애플리케이션 루트 모듈은 @Ngmodule 장식자를 이용해 정의한다.
```
@Ngmodule({
    imports : [BrowserModule, CommonModule, FormsModule ...] ,
    providers : [] ,
    declarations : [AppComponent, ...]
    bootstrap : [AppComponent]
  })

```



# @Ngmodule내 import영역

### 브라우저 모듈(BrowserModule) 151p
브라우저 모듈은 앵귤러가 브라우저에서 동작한다면 반드시 포함되어야함. 지시자, 파이프 같은 구성요소를 템플릿에 나타나게 하는 역할을 함.
브라우저 모듈은 공통 모듈을 재노출(re-exports) 한다는 것이다. 이 때문에 브라우저 모듈을 이미 선언했다면 공통 모듈을 선언하지 않아도 된다.

### 공통모듈(CommonModule) 151p
템플릿에서 사용하는 ngIf나 ngFor와 관련된 기능을 포함하고 있는 모듈이다.

### 폼모듈(FormsModule) 152p
템플릿에서 자주 사용하는 NgModel지시자나 내장 검증기 지시자 등을 포함하고 있다. 그래서 폼 모듈을 포함하면 NgModel과 같이 자주 사용하는 지시자를 별도로 추가하지 않아도 된다.

### AppRoutingModule 152p
사용자가 정의할 수 있는 라우팅 모듈이다. 애플리케이션 루트 모듈에 추가한 라우팅모듈은 애플리케이션 수준에서 라우팅을 수행한다.

# @Ngmodule내 provider영역
애플리케이션 전역에서 사용할 서비스를 등록.

# @Ngmodule내 declarations영역
애플리케이션 레벨에서 사용하고자 하는 컴포넌트, 지시자 파이프를 선언한다.

# @Ngmodule내 bootstrap영역
최상위 컴포넌트인 애플리케이션 컴포넌트를 등록

# router-outlet 152p
하위 특정 컴포넌트로 라우팅 후 하위 컴포넌ㅌ를 표시할 목적으로 라우터 아룰렛 지시자를 포함한다. 라우터 아울렛에 표시할 컴포넌트가 있다면 애플리케이션 라우팅 모듈 설정에 등록한다.

```
const appRoutes:Routes = [
  { path: '', component: IntroComponet},
  { path: 'hello', component: HelloComponent},
  ...
];

@NgModule({
  imports: [RouterModule.forRoot(appRoutes)],
  exports:[RouterModule]
  })
```
appRoutes 변수는 라우팅 설정을 담고 있으며 입력 URL에 대응하는 컴포넌트로 라우팅 되게 한다. appRoutes변수는 forRoot() 메소드를 이용해 등록한다. 유의할 점은 애플리케이션 라우팅 모듈에서만 한 번만 사용돼야 하고 특징 모듈에서는 사용하면 안된다.

애플리케이션 루트모듈에서는 다음과 같이 inports를 해줘야 한다.
```
@Ngmodule({
    imports : [AppRoutingModule ...] ,

```

## 핵심모듈 155p
앵귤러 어플리케이션 관점에서 핵심이 되는 모듈로 애플리케이션 루트 모듈에 한번 설정함을써 애플리케이션 레벨에서 사용할 수 있는 모듈을 말한다. 루트 모듈에 등록됐다는 것은 애플리케이션이 시작될 때 처음 한 번만 호출해서 전역으로 사용하겠다는 의미이다. 대표 예로 타이틀 컴포넌트가 있다. 보통 핵심 모듈은 /app/core에 위치시킨다.

## 특징모듈 161p
모듈이 많아지면 모듈 구성이 복잡해지며 지시자의 이름충돌 등의 문제가 발생할 수 있다. 이를 방지하기 위해 애플리케이션 루트 모듈에서 하위 모듈로 분리하는 것을 특징 모듈이라 한다. 특징 모듈에 선언한 모듈은 다른 모듈에 노출하거나 숨길수도 있다.
